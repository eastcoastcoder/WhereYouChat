{"version":3,"sources":["resources/leaflet.draw/ext/GeometryUtil.js"],"names":["defaultPrecision","km","ha","m","mi","ac","yd","ft","nm","L","GeometryUtil","extend","geodesicArea","latLngs","pointsCount","p1","p2","length","area","d2r","Math","PI","i","lng","sin","lat","abs","formattedNumber","n","precision","formatted","parseFloat","toFixed","format","drawLocal","numeric","delimiters","thousands","decimal","splitValue","split","replace","readableArea","isMetric","areaStr","units","Util","type","indexOf","readableDistance","distance","isFeet","isNauticalMile","distanceStr","isVersion07x","version","parseInt"],"mappings":"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","file":"GeometryUtil.05447028.map","sourceRoot":"..","sourcesContent":["(function () {\n\n\tvar defaultPrecision = {\n\t\tkm: 2,\n\t\tha: 2,\n\t\tm: 0,\n\t\tmi: 2,\n\t\tac: 2,\n\t\tyd: 0,\n\t\tft: 0,\n\t\tnm: 2\n\t};\n\n\n\t/**\n\t * @class L.GeometryUtil\n\t * @aka GeometryUtil\n\t */\n\tL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\t\t// Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270\n\n\t\t// @method geodesicArea(): number\n\t\tgeodesicArea: function (latLngs) {\n\t\t\tvar pointsCount = latLngs.length,\n\t\t\t\tarea = 0.0,\n\t\t\t\td2r = Math.PI / 180,\n\t\t\t\tp1, p2;\n\n\t\t\tif (pointsCount > 2) {\n\t\t\t\tfor (var i = 0; i < pointsCount; i++) {\n\t\t\t\t\tp1 = latLngs[i];\n\t\t\t\t\tp2 = latLngs[(i + 1) % pointsCount];\n\t\t\t\t\tarea += ((p2.lng - p1.lng) * d2r) *\n\t\t\t\t\t\t(2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));\n\t\t\t\t}\n\t\t\t\tarea = area * 6378137.0 * 6378137.0 / 2.0;\n\t\t\t}\n\n\t\t\treturn Math.abs(area);\n\t\t},\n\n\t\t// @method formattedNumber(n, precision): string\n\t\t// Returns n in specified number format (if defined) and precision\n\t\tformattedNumber: function (n, precision) {\n\t\t\tvar formatted = parseFloat(n).toFixed(precision),\n\t\t\t\tformat = L.drawLocal.format && L.drawLocal.format.numeric,\n\t\t\t\tdelimiters = format && format.delimiters,\n\t\t\t\tthousands = delimiters && delimiters.thousands,\n\t\t\t\tdecimal = delimiters && delimiters.decimal;\n\n\t\t\tif (thousands || decimal) {\n\t\t\t\tvar splitValue = formatted.split('.');\n\t\t\t\tformatted = thousands ? splitValue[0].replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + thousands) : splitValue[0];\n\t\t\t\tdecimal = decimal || '.';\n\t\t\t\tif (splitValue.length > 1) {\n\t\t\t\t\tformatted = formatted + decimal + splitValue[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formatted;\n\t\t},\n\n\t\t// @method readableArea(area, isMetric, precision): string\n\t\t// Returns a readable area string in yards or metric.\n\t\t// The value will be rounded as defined by the precision option object.\n\t\treadableArea: function (area, isMetric, precision) {\n\t\t\tvar areaStr,\n\t\t\t\tunits,\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\t\tif (isMetric) {\n\t\t\t\tunits = ['ha', 'm'];\n\t\t\t\ttype = typeof isMetric;\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tunits = [isMetric];\n\t\t\t\t} else if (type !== 'boolean') {\n\t\t\t\t\tunits = isMetric;\n\t\t\t\t}\n\n\t\t\t\tif (area >= 1000000 && units.indexOf('km') !== -1) {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.000001, precision['km']) + ' km²';\n\t\t\t\t} else if (area >= 10000 && units.indexOf('ha') !== -1) {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.0001, precision['ha']) + ' ha';\n\t\t\t\t} else {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['m']) + ' m²';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarea /= 0.836127; // Square yards in 1 meter\n\n\t\t\t\tif (area >= 3097600) { //3097600 square yards in 1 square mile\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 3097600, precision['mi']) + ' mi²';\n\t\t\t\t} else if (area >= 4840) { //4840 square yards in 1 acre\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 4840, precision['ac']) + ' acres';\n\t\t\t\t} else {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['yd']) + ' yd²';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn areaStr;\n\t\t},\n\n\t\t// @method readableDistance(distance, units): string\n\t\t// Converts a metric distance to one of [ feet, nauticalMile, metric or yards ] string\n\t\t//\n\t\t// @alternative\n\t\t// @method readableDistance(distance, isMetric, useFeet, isNauticalMile, precision): string\n\t\t// Converts metric distance to distance string.\n\t\t// The value will be rounded as defined by the precision option object.\n\t\treadableDistance: function (distance, isMetric, isFeet, isNauticalMile, precision) {\n\t\t\tvar distanceStr,\n\t\t\t\tunits,\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\t\tif (isMetric) {\n\t\t\t\tunits = typeof isMetric == 'string' ? isMetric : 'metric';\n\t\t\t} else if (isFeet) {\n\t\t\t\tunits = 'feet';\n\t\t\t} else if (isNauticalMile) {\n\t\t\t\tunits = 'nauticalMile';\n\t\t\t} else {\n\t\t\t\tunits = 'yards';\n\t\t\t}\n\n\t\t\tswitch (units) {\n\t\t\t\tcase 'metric':\n\t\t\t\t\t// show metres when distance is < 1km, then show km\n\t\t\t\t\tif (distance > 1000) {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['km']) + ' km';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['m']) + ' m';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'feet':\n\t\t\t\t\tdistance *= 1.09361 * 3;\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['ft']) + ' ft';\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'nauticalMile':\n\t\t\t\t\tdistance *= 0.53996;\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['nm']) + ' nm';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'yards':\n\t\t\t\tdefault:\n\t\t\t\t\tdistance *= 1.09361;\n\n\t\t\t\t\tif (distance > 1760) {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1760, precision['mi']) + ' miles';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['yd']) + ' yd';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn distanceStr;\n\t\t},\n\n\t\t// @method isVersion07x(): boolean\n\t\t// Returns true if the Leaflet version is 0.7.x, false otherwise.\n\t\tisVersion07x: function () {\n\t\t\tvar version = L.version.split('.');\n\t\t\t//If Version is == 0.7.*\n\t\t\treturn parseInt(version[0], 10) === 0 && parseInt(version[1], 10) === 7;\n\t\t},\n\t});\n\n})();\n"]}