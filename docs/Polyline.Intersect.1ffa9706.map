{"version":3,"sources":["resources/leaflet.draw/ext/Polyline.Intersect.js"],"names":["L","Polyline","include","intersects","points","i","p","p1","_getProjectedPoints","len","length","_tooFewPointsForIntersection","_lineSegmentsIntersectsRange","newLatLngIntersects","latlng","skipFirst","_map","newPointIntersects","latLngToLayerPoint","newPoint","lastPoint","maxIndex","extraPoints","minIndex","p2","p3","j","LineUtil","segmentsIntersect","_defaultShape","_originalPoints","_shape","push"],"mappings":";AAIAA,EAAEC,SAASC,QAAQ,CAKlBC,WAAY,WACPC,IAEHC,EAAGC,EAAGC,EAFHH,EAAS,KAAKI,sBACjBC,EAAML,EAASA,EAAOM,OAAS,EAG5B,GAAA,KAAKC,+BACD,OAAA,EAGHN,IAAAA,EAAII,EAAM,EAAGJ,GAAK,EAAGA,IAKrB,GAJJC,EAAIF,EAAOC,EAAI,GACfE,EAAKH,EAAOC,GAGR,KAAKO,6BAA6BN,EAAGC,EAAIF,EAAI,GACzC,OAAA,EAIF,OAAA,GAMRQ,oBAAqB,SAAUC,EAAQC,GAElC,QAAC,KAAKC,MAIH,KAAKC,mBAAmB,KAAKD,KAAKE,mBAAmBJ,GAASC,IAOtEE,mBAAoB,SAAUE,EAAUJ,GACnCX,IAAAA,EAAS,KAAKI,sBACjBC,EAAML,EAASA,EAAOM,OAAS,EAC/BU,EAAYhB,EAASA,EAAOK,EAAM,GAAK,KAEvCY,EAAWZ,EAAM,EAEd,OAAA,KAAKE,6BAA6B,IAI/B,KAAKC,6BAA6BQ,EAAWD,EAAUE,EAAUN,EAAY,EAAI,IAKzFJ,6BAA8B,SAAUW,GACnClB,IAAAA,EAAS,KAAKI,sBACjBC,EAAML,EAASA,EAAOM,OAAS,EAIzB,OAACN,IAFRK,GAAOa,GAAe,IAEG,GAK1BV,6BAA8B,SAAUN,EAAGC,EAAIc,EAAUE,GACpDnB,IACHoB,EAAIC,EADDrB,EAAS,KAAKI,sBAGlBe,EAAWA,GAAY,EAGlB,IAAA,IAAIG,EAAIL,EAAUK,EAAIH,EAAUG,IAIhC1B,GAHJwB,EAAKpB,EAAOsB,EAAI,GAChBD,EAAKrB,EAAOsB,GAER1B,EAAE2B,SAASC,kBAAkBtB,EAAGC,EAAIiB,EAAIC,GACpC,OAAA,EAIF,OAAA,GAGRjB,oBAAqB,WAChB,IAAC,KAAKqB,cACF,OAAA,KAAKC,gBAKR,IAHD1B,IAAAA,EAAS,GACZ2B,EAAS,KAAKF,gBAENxB,EAAI,EAAGA,EAAI0B,EAAOrB,OAAQL,IAClCD,EAAO4B,KAAK,KAAKhB,KAAKE,mBAAmBa,EAAO1B,KAE1CD,OAAAA","file":"Polyline.Intersect.1ffa9706.map","sourceRoot":"..","sourcesContent":["/**\n * @class L.Polyline\n * @aka Polyline\n */\nL.Polyline.include({\n\n\t// @method intersects(): boolean\n\t// Check to see if this polyline has any linesegments that intersect.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tintersects: function () {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0,\n\t\t\ti, p, p1;\n\n\t\tif (this._tooFewPointsForIntersection()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = len - 1; i >= 3; i--) {\n\t\t\tp = points[i - 1];\n\t\t\tp1 = points[i];\n\n\n\t\t\tif (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// @method newLatLngIntersects(): boolean\n\t// Check for intersection if new latlng was added to this polyline.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tnewLatLngIntersects: function (latlng, skipFirst) {\n\t\t// Cannot check a polyline for intersecting lats/lngs when not added to the map\n\t\tif (!this._map) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\n\t},\n\n\t// @method newPointIntersects(): boolean\n\t// Check for intersection if new point was added to this polyline.\n\t// newPoint must be a layer point.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tnewPointIntersects: function (newPoint, skipFirst) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0,\n\t\t\tlastPoint = points ? points[len - 1] : null,\n\t\t\t// The previous previous line segment. Previous line segment doesn't need testing.\n\t\t\tmaxIndex = len - 2;\n\n\t\tif (this._tooFewPointsForIntersection(1)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\n\t},\n\n\t// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\n\t// Cannot have intersection when < 3 line segments (< 4 points)\n\t_tooFewPointsForIntersection: function (extraPoints) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0;\n\t\t// Increment length by extraPoints if present\n\t\tlen += extraPoints || 0;\n\n\t\treturn !points || len <= 3;\n\t},\n\n\t// Checks a line segment intersections with any line segments before its predecessor.\n\t// Don't need to check the predecessor as will never intersect.\n\t_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tp2, p3;\n\n\t\tminIndex = minIndex || 0;\n\n\t\t// Check all previous line segments (beside the immediately previous) for intersections\n\t\tfor (var j = maxIndex; j > minIndex; j--) {\n\t\t\tp2 = points[j - 1];\n\t\t\tp3 = points[j];\n\n\t\t\tif (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_getProjectedPoints: function () {\n\t\tif (!this._defaultShape) {\n\t\t\treturn this._originalPoints;\n\t\t}\n\t\tvar points = [],\n\t\t\t_shape = this._defaultShape();\n\n\t\tfor (var i = 0; i < _shape.length; i++) {\n\t\t\tpoints.push(this._map.latLngToLayerPoint(_shape[i]));\n\t\t}\n\t\treturn points;\n\t}\n});\n"]}