{"version":3,"sources":["resources/leaflet.draw/draw/handler/Draw.Polyline.js"],"names":["L","Draw","Polyline","Feature","extend","statics","TYPE","Poly","options","allowIntersection","repeatMode","drawError","color","timeout","icon","DivIcon","iconSize","Point","className","touchIcon","guidelineDistance","maxGuideLineLength","shapeOptions","stroke","weight","opacity","fill","clickable","metric","feet","nautic","showLength","zIndexOffset","factor","maxPoints","initialize","map","Browser","touch","message","drawLocal","draw","handlers","polyline","error","Util","type","prototype","call","addHooks","_map","_markers","_markerGroup","LayerGroup","addLayer","_poly","_tooltip","updateContent","_getTooltipText","_mouseMarker","marker","getCenter","divIcon","iconAnchor","on","_onMouseOut","_onMouseMove","_onMouseDown","_onMouseUp","addTo","_onZoomEnd","_onTouch","removeHooks","_clearHideErrorTimeout","_cleanUpShape","removeLayer","off","_clearGuides","deleteLastVertex","length","lastMarker","pop","poly","latlngs","getLatLngs","latlng","splice","setLatLngs","_vertexChanged","addVertex","newLatLngIntersects","_showErrorTooltip","_errorShown","_hideErrorTooltip","push","_createMarker","addLatLng","completeShape","_fireCreatedEvent","disable","enable","_finishShape","_defaultShape","intersects","_shapeIsValid","_updateGuide","e","newPos","mouseEventToLayerPoint","originalEvent","layerPointToLatLng","_currentLatLng","_updateTooltip","setLatLng","DomEvent","preventDefault","added","fire","Event","DRAWVERTEX","layers","_updateFinishHandler","_updateRunningMeasure","_clickHandled","_touchHandled","_disableMarkers","_disableNewMarkers","clientX","clientY","_startPoint","_mouseDownOrigin","point","_endPoint","dragCheckDistance","distanceTo","lastPtDistance","_calculateFinishDistance","Math","abs","window","devicePixelRatio","_enableNewMarkers","touches","potentialLatLng","finishMarker","Polygon","Infinity","lastMarkerPoint","latLngToContainerPoint","getLatLng","potentialMarker","Marker","potentialMarkerPint","markerCount","latLngToLayerPoint","_drawGuide","latLng","text","updatePosition","pointA","pointB","fraction","dashPoint","dash","floor","sqrt","pow","x","y","i","_guidesContainer","DomUtil","create","_overlayPane","style","backgroundColor","setPosition","_updateGuideColor","l","childNodes","firstChild","removeChild","labelText","distanceStr","tooltip","start","_getMeasurementString","cont","subtext","end","markersLength","previousMarkerIndex","distance","_measurementRunningTotal","GeometryUtil","isVersion07x","currentLatLng","previousLatLng","readableDistance","precision","showAsError","setStyle","_hideErrorTimeout","setTimeout","bind","removeError","clearTimeout"],"mappings":";AAKAA,EAAEC,KAAKC,SAAWF,EAAEC,KAAKE,QAAQC,OAAO,CACvCC,QAAS,CACRC,KAAM,YAGPC,KAAMP,EAAEE,SAERM,QAAS,CACRC,mBAAmB,EACnBC,YAAY,EACZC,UAAW,CACVC,MAAO,UACPC,QAAS,MAEVC,KAAM,IAAId,EAAEe,QAAQ,CACnBC,SAAU,IAAIhB,EAAEiB,MAAM,EAAG,GACzBC,UAAW,0CAEZC,UAAW,IAAInB,EAAEe,QAAQ,CACxBC,SAAU,IAAIhB,EAAEiB,MAAM,GAAI,IAC1BC,UAAW,6DAEZE,kBAAmB,GACnBC,mBAAoB,IACpBC,aAAc,CACbC,QAAQ,EACRX,MAAO,UACPY,OAAQ,EACRC,QAAS,GACTC,MAAM,EACNC,WAAW,GAEZC,QAAQ,EACRC,MAAM,EACNC,QAAQ,EACRC,YAAY,EACZC,aAAc,IACdC,OAAQ,EACRC,UAAW,GAIZC,WAAY,SAAUC,EAAK5B,GAEtBR,EAAEqC,QAAQC,QACR9B,KAAAA,QAAQM,KAAO,KAAKN,QAAQW,WAI7BX,KAAAA,QAAQG,UAAU4B,QAAUvC,EAAEwC,UAAUC,KAAKC,SAASC,SAASC,MAGhEpC,GAAWA,EAAQG,YACtBH,EAAQG,UAAYX,EAAE6C,KAAKzC,OAAO,GAAI,KAAKI,QAAQG,UAAWH,EAAQG,YAIlEmC,KAAAA,KAAO9C,EAAEC,KAAKC,SAASI,KAE5BN,EAAEC,KAAKE,QAAQ4C,UAAUZ,WAAWa,KAAK,KAAMZ,EAAK5B,IAKrDyC,SAAU,WACTjD,EAAEC,KAAKE,QAAQ4C,UAAUE,SAASD,KAAK,MACnC,KAAKE,OACHC,KAAAA,SAAW,GAEXC,KAAAA,aAAe,IAAIpD,EAAEqD,WACrBH,KAAAA,KAAKI,SAAS,KAAKF,cAEnBG,KAAAA,MAAQ,IAAIvD,EAAEE,SAAS,GAAI,KAAKM,QAAQc,cAExCkC,KAAAA,SAASC,cAAc,KAAKC,mBAO5B,KAAKC,eACJA,KAAAA,aAAe3D,EAAE4D,OAAO,KAAKV,KAAKW,YAAa,CACnD/C,KAAMd,EAAE8D,QAAQ,CACf5C,UAAW,uBACX6C,WAAY,CAAC,GAAI,IACjB/C,SAAU,CAAC,GAAI,MAEhBS,QAAS,EACTO,aAAc,KAAKxB,QAAQwB,gBAIxB2B,KAAAA,aACHK,GAAG,WAAY,KAAKC,YAAa,MACjCD,GAAG,YAAa,KAAKE,aAAc,MACnCF,GAAG,YAAa,KAAKG,aAAc,MACnCH,GAAG,UAAW,KAAKI,WAAY,MAC/BC,MAAM,KAAKnB,MAERA,KAAAA,KACHc,GAAG,UAAW,KAAKI,WAAY,MAC/BJ,GAAG,YAAa,KAAKE,aAAc,MACnCF,GAAG,mBAAoB,KAAKM,WAAY,MACxCN,GAAG,aAAc,KAAKO,SAAU,MAChCP,GAAG,UAAW,KAAKM,WAAY,QAOnCE,YAAa,WACZxE,EAAEC,KAAKE,QAAQ4C,UAAUyB,YAAYxB,KAAK,MAErCyB,KAAAA,yBAEAC,KAAAA,gBAGAxB,KAAAA,KAAKyB,YAAY,KAAKvB,qBACpB,KAAKA,oBACL,KAAKD,SAEPD,KAAAA,KAAKyB,YAAY,KAAKpB,cACpB,KAAKA,MAEPI,KAAAA,aACHiB,IAAI,YAAa,KAAKT,aAAc,MACpCS,IAAI,WAAY,KAAKX,YAAa,MAClCW,IAAI,UAAW,KAAKR,WAAY,MAChCQ,IAAI,YAAa,KAAKV,aAAc,MACjChB,KAAAA,KAAKyB,YAAY,KAAKhB,qBACpB,KAAKA,aAGPkB,KAAAA,eAEA3B,KAAAA,KACH0B,IAAI,UAAW,KAAKR,WAAY,MAChCQ,IAAI,YAAa,KAAKV,aAAc,MACpCU,IAAI,mBAAoB,KAAKN,WAAY,MACzCM,IAAI,UAAW,KAAKN,WAAY,MAChCM,IAAI,aAAc,KAAKL,SAAU,MACjCK,IAAI,QAAS,KAAKL,SAAU,OAK/BO,iBAAkB,WACb,KAAA,KAAK3B,SAAS4B,QAAU,GAAxB,CAIAC,IAAAA,EAAa,KAAK7B,SAAS8B,MAC9BC,EAAO,KAAK3B,MAEZ4B,EAAUD,EAAKE,aACfC,EAASF,EAAQG,QAAQ,EAAG,GAAG,GAC3B/B,KAAAA,MAAMgC,WAAWJ,GAEjB/B,KAAAA,aAAauB,YAAYK,GAE1BE,EAAKE,aAAaL,OAAS,GACzB7B,KAAAA,KAAKyB,YAAYO,GAGlBM,KAAAA,eAAeH,GAAQ,KAK7BI,UAAW,SAAUJ,GACA,KAAKlC,SAAS4B,QAEb,IAAM,KAAKvE,QAAQC,mBAAqB,KAAK8C,MAAMmC,oBAAoBL,GACtFM,KAAAA,qBAGG,KAAKC,aACRC,KAAAA,oBAGD1C,KAAAA,SAAS2C,KAAK,KAAKC,cAAcV,IAEjC9B,KAAAA,MAAMyC,UAAUX,GAEkB,IAAnC,KAAK9B,MAAM6B,aAAaL,QACtB7B,KAAAA,KAAKI,SAAS,KAAKC,OAGpBiC,KAAAA,eAAeH,GAAQ,KAK7BY,cAAe,WACV,KAAK9C,SAAS4B,QAAU,IAIvBmB,KAAAA,oBACAC,KAAAA,UAED,KAAK3F,QAAQE,YACX0F,KAAAA,WAIPC,aAAc,WACTlB,IAAAA,EAAU,KAAK5B,MAAM+C,cAAgB,KAAK/C,MAAM+C,gBAAkB,KAAK/C,MAAM6B,aAC7EmB,EAAa,KAAKhD,MAAMmC,oBAAoBP,EAAQA,EAAQJ,OAAS,KAEnE,KAAKvE,QAAQC,mBAAqB8F,IAAgB,KAAKC,gBACvDb,KAAAA,qBAIDO,KAAAA,oBACAC,KAAAA,UACD,KAAK3F,QAAQE,YACX0F,KAAAA,WAMPI,cAAe,WACP,OAAA,GAGRlC,WAAY,WACW,OAAlB,KAAKnB,UACHsD,KAAAA,gBAIPvC,aAAc,SAAUwC,GACnBC,IAAAA,EAAS,KAAKzD,KAAK0D,uBAAuBF,EAAEG,eAC5CxB,EAAS,KAAKnC,KAAK4D,mBAAmBH,GAIrCI,KAAAA,eAAiB1B,EAEjB2B,KAAAA,eAAe3B,GAGfoB,KAAAA,aAAaE,GAGbhD,KAAAA,aAAasD,UAAU5B,GAE5BrF,EAAEkH,SAASC,eAAeT,EAAEG,gBAG7BrB,eAAgB,SAAUH,EAAQ+B,GAC5BlE,KAAAA,KAAKmE,KAAKrH,EAAEC,KAAKqH,MAAMC,WAAY,CAACC,OAAQ,KAAKpE,eACjDqE,KAAAA,uBAEAC,KAAAA,sBAAsBrC,EAAQ+B,GAE9BvC,KAAAA,eAEAmC,KAAAA,kBAGN7C,aAAc,SAAUuC,GACnB,IAAC,KAAKiB,gBAAkB,KAAKC,gBAAkB,KAAKC,gBAAiB,CACnE3D,KAAAA,aAAawC,GACbiB,KAAAA,eAAgB,EAChBG,KAAAA,qBACDjB,IAAAA,EAAgBH,EAAEG,cAClBkB,EAAUlB,EAAckB,QACxBC,EAAUnB,EAAcmB,QACvBC,KAAAA,YAAYjF,KAAK,KAAM+E,EAASC,KAIvCC,YAAa,SAAUF,EAASC,GAC1BE,KAAAA,iBAAmBlI,EAAEmI,MAAMJ,EAASC,IAG1C5D,WAAY,SAAUsC,GACjBG,IAAAA,EAAgBH,EAAEG,cAClBkB,EAAUlB,EAAckB,QACxBC,EAAUnB,EAAcmB,QACvBI,KAAAA,UAAUpF,KAAK,KAAM+E,EAASC,EAAStB,GACvCiB,KAAAA,cAAgB,MAGtBS,UAAW,SAAUL,EAASC,EAAStB,GAClC,GAAA,KAAKwB,iBAAkB,CACtBG,IAAAA,EAAoBrI,EAAEmI,MAAMJ,EAASC,GACvCM,WAAW,KAAKJ,kBACdK,EAAiB,KAAKC,yBAAyB9B,EAAErB,QACjD,KAAK7E,QAAQ0B,UAAY,GAAK,KAAK1B,QAAQ0B,WAAa,KAAKiB,SAAS4B,OAAS,GAC7EU,KAAAA,UAAUiB,EAAErB,QACZgB,KAAAA,gBACKkC,EAAiB,IAAMvI,EAAEqC,QAAQC,MACtC+D,KAAAA,eACKoC,KAAKC,IAAIL,GAAqB,GAAKM,OAAOC,kBAAoB,IACnEnD,KAAAA,UAAUiB,EAAErB,QAEbwD,KAAAA,oBAEDX,KAAAA,iBAAmB,MAKzB3D,SAAU,SAAUmC,GACfG,IACAkB,EACAC,EAFAnB,EAAgBH,EAAEG,eAGlBA,EAAciC,UAAWjC,EAAciC,QAAQ,IAAO,KAAKnB,eAAkB,KAAKC,eAAkB,KAAKC,kBAC5GE,EAAUlB,EAAciC,QAAQ,GAAGf,QACnCC,EAAUnB,EAAciC,QAAQ,GAAGd,QAC9BF,KAAAA,qBACAF,KAAAA,eAAgB,EAChBK,KAAAA,YAAYjF,KAAK,KAAM+E,EAASC,GAChCI,KAAAA,UAAUpF,KAAK,KAAM+E,EAASC,EAAStB,GACvCkB,KAAAA,cAAgB,MAEjBD,KAAAA,cAAgB,MAGtB1D,YAAa,WACR,KAAKT,UACHA,KAAAA,SAASS,YAAYjB,KAAK,KAAKQ,WAQtCgF,yBAA0B,SAAUO,GAC/BR,IAAAA,EACA,GAAA,KAAKpF,SAAS4B,OAAS,EAAG,CACzBiE,IAAAA,EACA,GAAA,KAAKlG,OAAS9C,EAAEC,KAAKC,SAASI,KACjC0I,EAAe,KAAK7F,SAAS,KAAKA,SAAS4B,OAAS,OAC9C,CAAA,GAAI,KAAKjC,OAAS9C,EAAEC,KAAKgJ,QAAQ3I,KAGhC4I,OAAAA,EAAAA,EAFPF,EAAe,KAAK7F,SAAS,GAI1BgG,IAAAA,EAAkB,KAAKjG,KAAKkG,uBAAuBJ,EAAaK,aACnEC,EAAkB,IAAItJ,EAAEuJ,OAAOR,EAAiB,CAC/CjI,KAAM,KAAKN,QAAQM,KACnBkB,aAA0C,EAA5B,KAAKxB,QAAQwB,eAEzBwH,EAAsB,KAAKtG,KAAKkG,uBAAuBE,EAAgBD,aAC3Ed,EAAiBY,EAAgBb,WAAWkB,QAE5CjB,EAAiBW,EAAAA,EAEXX,OAAAA,GAGRd,qBAAsB,WACjBgC,IAAAA,EAAc,KAAKtG,SAAS4B,OAE5B0E,EAAc,GACZtG,KAAAA,SAASsG,EAAc,GAAGzF,GAAG,QAAS,KAAKqC,aAAc,MAI3DoD,EAAc,GACZtG,KAAAA,SAASsG,EAAc,GAAG7E,IAAI,QAAS,KAAKyB,aAAc,OAIjEN,cAAe,SAAUV,GACpBzB,IAAAA,EAAS,IAAI5D,EAAEuJ,OAAOlE,EAAQ,CACjCvE,KAAM,KAAKN,QAAQM,KACnBkB,aAA0C,EAA5B,KAAKxB,QAAQwB,eAKrB4B,OAFFR,KAAAA,aAAaE,SAASM,GAEpBA,GAGR6C,aAAc,SAAUE,GACnB8C,IAAAA,EAAc,KAAKtG,SAAW,KAAKA,SAAS4B,OAAS,EAErD0E,EAAc,IACjB9C,EAASA,GAAU,KAAKzD,KAAKwG,mBAAmB,KAAK3C,gBAGhDlC,KAAAA,eACA8E,KAAAA,WACJ,KAAKzG,KAAKwG,mBAAmB,KAAKvG,SAASsG,EAAc,GAAGJ,aAC5D1C,KAKHK,eAAgB,SAAU4C,GACrBC,IAAAA,EAAO,KAAKnG,kBAEZkG,GACEpG,KAAAA,SAASsG,eAAeF,GAGzB,KAAKhE,aACJpC,KAAAA,SAASC,cAAcoG,IAI9BF,WAAY,SAAUI,EAAQC,GACzBjF,IAKHkF,EACAC,EACAC,EAPGpF,EAAS0D,KAAK2B,MAAM3B,KAAK4B,KAAK5B,KAAK6B,IAAKN,EAAOO,EAAIR,EAAOQ,EAAI,GAAK9B,KAAK6B,IAAKN,EAAOQ,EAAIT,EAAOS,EAAI,KACtGpJ,EAAoB,KAAKZ,QAAQY,kBACjCC,EAAqB,KAAKb,QAAQa,mBAElCoJ,EAAI1F,EAAS1D,EAAqB0D,EAAS1D,EAAqBD,EAW1DqJ,IALF,KAAKC,mBACJA,KAAAA,iBAAmB1K,EAAE2K,QAAQC,OAAO,MAAO,sBAAuB,KAAKC,eAItEJ,EAAI1F,EAAQ0F,GAAK,KAAKjK,QAAQY,kBAEpC6I,EAAWQ,EAAI1F,EAGfmF,EAAY,CACXK,EAAG9B,KAAK2B,MAAOL,EAAOQ,GAAK,EAAIN,GAAcA,EAAWD,EAAOO,GAC/DC,EAAG/B,KAAK2B,MAAOL,EAAOS,GAAK,EAAIP,GAAcA,EAAWD,EAAOQ,KAIhEL,EAAOnK,EAAE2K,QAAQC,OAAO,MAAO,0BAA2B,KAAKF,mBAC1DI,MAAMC,gBACT,KAAKnF,YAAgD,KAAKpF,QAAQG,UAAUC,MAAzD,KAAKJ,QAAQc,aAAaV,MAE/CZ,EAAE2K,QAAQK,YAAYb,EAAMD,IAI9Be,kBAAmB,SAAUrK,GACxB,GAAA,KAAK8J,iBACH,IAAA,IAAID,EAAI,EAAGS,EAAI,KAAKR,iBAAiBS,WAAWpG,OAAQ0F,EAAIS,EAAGT,IAC9DC,KAAAA,iBAAiBS,WAAWV,GAAGK,MAAMC,gBAAkBnK,GAM/DiE,aAAc,WACT,GAAA,KAAK6F,iBACD,KAAA,KAAKA,iBAAiBU,YACvBV,KAAAA,iBAAiBW,YAAY,KAAKX,iBAAiBU,aAK3D1H,gBAAiB,WACZ3B,IACHuJ,EAAWC,EADRxJ,EAAa,KAAKvB,QAAQuB,WAqBvBuJ,OAnBsB,IAAzB,KAAKnI,SAAS4B,OACjBuG,EAAY,CACXzB,KAAM7J,EAAEwC,UAAUC,KAAKC,SAASC,SAAS6I,QAAQC,QAGlDF,EAAcxJ,EAAa,KAAK2J,wBAA0B,GAGzDJ,EAD4B,IAAzB,KAAKnI,SAAS4B,OACL,CACX8E,KAAM7J,EAAEwC,UAAUC,KAAKC,SAASC,SAAS6I,QAAQG,KACjDC,QAASL,GAGE,CACX1B,KAAM7J,EAAEwC,UAAUC,KAAKC,SAASC,SAAS6I,QAAQK,IACjDD,QAASL,IAILD,GAGR5D,sBAAuB,SAAUrC,EAAQ+B,GACpC0E,IACHC,EAAqBC,EADlBF,EAAgB,KAAK3I,SAAS4B,OAGL,IAAzB,KAAK5B,SAAS4B,OACZkH,KAAAA,yBAA2B,GAEhCF,EAAsBD,GAAiB1E,EAAQ,EAAI,GAIlD4E,EADGhM,EAAEkM,aAAaC,eACP9G,EAAOiD,WAAW,KAAKnF,SAAS4I,GAAqB1C,cAAgB,KAAK7I,QAAQyB,QAAU,GAE5F,KAAKiB,KAAK8I,SAAS3G,EAAQ,KAAKlC,SAAS4I,GAAqB1C,cAAgB,KAAK7I,QAAQyB,QAAU,GAG5GgK,KAAAA,0BAA4BD,GAAY5E,EAAQ,GAAK,KAI5DsE,sBAAuB,WAClBU,IAEHJ,EAFGI,EAAgB,KAAKrF,eACxBsF,EAAiB,KAAKlJ,SAAS,KAAKA,SAAS4B,OAAS,GAAGsE,YAUnDrJ,OALNgM,EADGhM,EAAEkM,aAAaC,eACPE,GAAkBD,GAAiBA,EAAc9D,WAAa,KAAK2D,yBAA2BG,EAAc9D,WAAW+D,IAAmB,KAAK7L,QAAQyB,QAAU,GAAK,KAAKgK,0BAA4B,EAEvMI,GAAkBD,EAAgB,KAAKH,yBAA2B,KAAK/I,KAAK8I,SAASI,EAAeC,IAAmB,KAAK7L,QAAQyB,QAAU,GAAK,KAAKgK,0BAA4B,EAGzLjM,EAAEkM,aAAaI,iBAAiBN,EAAU,KAAKxL,QAAQoB,OAAQ,KAAKpB,QAAQqB,KAAM,KAAKrB,QAAQsB,OAAQ,KAAKtB,QAAQ+L,YAG5H5G,kBAAmB,WACbC,KAAAA,aAAc,EAGdpC,KAAAA,SACHgJ,cACA/I,cAAc,CAACoG,KAAM,KAAKrJ,QAAQG,UAAU4B,UAGzC0I,KAAAA,kBAAkB,KAAKzK,QAAQG,UAAUC,OACzC2C,KAAAA,MAAMkJ,SAAS,CAAC7L,MAAO,KAAKJ,QAAQG,UAAUC,QAG9C6D,KAAAA,yBACAiI,KAAAA,kBAAoBC,WAAW3M,EAAE6C,KAAK+J,KAAK,KAAK/G,kBAAmB,MAAO,KAAKrF,QAAQG,UAAUE,UAGvGgF,kBAAmB,WACbD,KAAAA,aAAc,EAEdnB,KAAAA,yBAGAjB,KAAAA,SACHqJ,cACApJ,cAAc,KAAKC,mBAGhBuH,KAAAA,kBAAkB,KAAKzK,QAAQc,aAAaV,OAC5C2C,KAAAA,MAAMkJ,SAAS,CAAC7L,MAAO,KAAKJ,QAAQc,aAAaV,SAGvD6D,uBAAwB,WACnB,KAAKiI,oBACRI,aAAa,KAAKJ,mBACbA,KAAAA,kBAAoB,OAM3B5E,mBAAoB,WACdD,KAAAA,iBAAkB,GAIxBgB,kBAAmB,WAClB8D,WAAW,WACL9E,KAAAA,iBAAkB,GACtB+E,KAAK,MAAO,KAGflI,cAAe,WACV,KAAKvB,SAAS4B,OAAS,GACrB5B,KAAAA,SAAS,KAAKA,SAAS4B,OAAS,GAAGH,IAAI,QAAS,KAAKyB,aAAc,OAI1EH,kBAAmB,WACdhB,IAAAA,EAAO,IAAI,KAAK3E,KAAK,KAAKgD,MAAM6B,aAAc,KAAK5E,QAAQc,cAC/DtB,EAAEC,KAAKE,QAAQ4C,UAAUmD,kBAAkBlD,KAAK,KAAMkC","file":"Draw.Polyline.f9233904.map","sourceRoot":"..","sourcesContent":["/**\n * @class L.Draw.Polyline\n * @aka Draw.Polyline\n * @inherits L.Draw.Feature\n */\nL.Draw.Polyline = L.Draw.Feature.extend({\n\tstatics: {\n\t\tTYPE: 'polyline'\n\t},\n\n\tPoly: L.Polyline,\n\n\toptions: {\n\t\tallowIntersection: true,\n\t\trepeatMode: false,\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 2500\n\t\t},\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tguidelineDistance: 20,\n\t\tmaxGuideLineLength: 4000,\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: false,\n\t\t\tclickable: true\n\t\t},\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\n\t\tshowLength: true, // Whether to display distance in the tooltip\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any map layers\n\t\tfactor: 1, // To change distance calculation\n\t\tmaxPoints: 0 // Once this number of points are placed, finish shape\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\n\t\t// Need to set this here to ensure the correct message is used.\n\t\tthis.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;\n\n\t\t// Merge default drawError options with custom options\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Polyline.TYPE;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._markers = [];\n\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t\tthis._map.addLayer(this._markerGroup);\n\n\t\t\tthis._poly = new L.Polyline([], this.options.shapeOptions);\n\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\n\t\t\t// Make a transparent marker that will used to catch click events. These click\n\t\t\t// events will create the vertices. We need to do this so we can ensure that\n\t\t\t// we can create vertices over other map layers (markers, vector layers). We\n\t\t\t// also do not want to trigger any click handlers of objects we are clicking on\n\t\t\t// while drawing.\n\t\t\tif (!this._mouseMarker) {\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\n\t\t\t\t\ticon: L.divIcon({\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\n\t\t\t\t\t\ticonAnchor: [20, 20],\n\t\t\t\t\t\ticonSize: [40, 40]\n\t\t\t\t\t}),\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseMarker\n\t\t\t\t.on('mouseout', this._onMouseOut, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this) // Necessary to prevent 0.8 stutter\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.8 compatibility\n\t\t\t\t.addTo(this._map);\n\n\t\t\tthis._map\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.7 compatibility\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t\t.on('touchstart', this._onTouch, this)\n\t\t\t\t.on('zoomend', this._onZoomEnd, this);\n\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\tthis._cleanUpShape();\n\n\t\t// remove markers from map\n\t\tthis._map.removeLayer(this._markerGroup);\n\t\tdelete this._markerGroup;\n\t\tdelete this._markers;\n\n\t\tthis._map.removeLayer(this._poly);\n\t\tdelete this._poly;\n\n\t\tthis._mouseMarker\n\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t.off('mouseout', this._onMouseOut, this)\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this);\n\t\tthis._map.removeLayer(this._mouseMarker);\n\t\tdelete this._mouseMarker;\n\n\t\t// clean up DOM\n\t\tthis._clearGuides();\n\n\t\tthis._map\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t.off('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t.off('zoomend', this._onZoomEnd, this)\n\t\t\t.off('touchstart', this._onTouch, this)\n\t\t\t.off('click', this._onTouch, this);\n\t},\n\n\t// @method deleteLastVertex(): void\n\t// Remove the last vertex from the polyline, removes polyline from map if only one point exists.\n\tdeleteLastVertex: function () {\n\t\tif (this._markers.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lastMarker = this._markers.pop(),\n\t\t\tpoly = this._poly,\n\t\t\t// Replaces .spliceLatLngs()\n\t\t\tlatlngs = poly.getLatLngs(),\n\t\t\tlatlng = latlngs.splice(-1, 1)[0];\n\t\tthis._poly.setLatLngs(latlngs);\n\n\t\tthis._markerGroup.removeLayer(lastMarker);\n\n\t\tif (poly.getLatLngs().length < 2) {\n\t\t\tthis._map.removeLayer(poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, false);\n\t},\n\n\t// @method addVertex(): void\n\t// Add a vertex to the end of the polyline\n\taddVertex: function (latlng) {\n\t\tvar markersLength = this._markers.length;\n\t\t// markersLength must be greater than or equal to 2 before intersections can occur\n\t\tif (markersLength >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\t\telse if (this._errorShown) {\n\t\t\tthis._hideErrorTooltip();\n\t\t}\n\n\t\tthis._markers.push(this._createMarker(latlng));\n\n\t\tthis._poly.addLatLng(latlng);\n\n\t\tif (this._poly.getLatLngs().length === 2) {\n\t\t\tthis._map.addLayer(this._poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, true);\n\t},\n\n\t// @method completeShape(): void\n\t// Closes the polyline between the first and last points\n\tcompleteShape: function () {\n\t\tif (this._markers.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t_finishShape: function () {\n\t\tvar latlngs = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs();\n\t\tvar intersects = this._poly.newLatLngIntersects(latlngs[latlngs.length - 1]);\n\n\t\tif ((!this.options.allowIntersection && intersects) || !this._shapeIsValid()) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t// Called to verify the shape is valid when the user tries to finish it\n\t// Return false if the shape is not valid\n\t_shapeIsValid: function () {\n\t\treturn true;\n\t},\n\n\t_onZoomEnd: function () {\n\t\tif (this._markers !== null) {\n\t\t\tthis._updateGuide();\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar newPos = this._map.mouseEventToLayerPoint(e.originalEvent);\n\t\tvar latlng = this._map.layerPointToLatLng(newPos);\n\n\t\t// Save latlng\n\t\t// should this be moved to _updateGuide() ?\n\t\tthis._currentLatLng = latlng;\n\n\t\tthis._updateTooltip(latlng);\n\n\t\t// Update the guide line\n\t\tthis._updateGuide(newPos);\n\n\t\t// Update the mouse marker position\n\t\tthis._mouseMarker.setLatLng(latlng);\n\n\t\tL.DomEvent.preventDefault(e.originalEvent);\n\t},\n\n\t_vertexChanged: function (latlng, added) {\n\t\tthis._map.fire(L.Draw.Event.DRAWVERTEX, {layers: this._markerGroup});\n\t\tthis._updateFinishHandler();\n\n\t\tthis._updateRunningMeasure(latlng, added);\n\n\t\tthis._clearGuides();\n\n\t\tthis._updateTooltip();\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tif (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tthis._onMouseMove(e);\n\t\t\tthis._clickHandled = true;\n\t\t\tthis._disableNewMarkers();\n\t\t\tvar originalEvent = e.originalEvent;\n\t\t\tvar clientX = originalEvent.clientX;\n\t\t\tvar clientY = originalEvent.clientY;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t}\n\t},\n\n\t_startPoint: function (clientX, clientY) {\n\t\tthis._mouseDownOrigin = L.point(clientX, clientY);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX = originalEvent.clientX;\n\t\tvar clientY = originalEvent.clientY;\n\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\tthis._clickHandled = null;\n\t},\n\n\t_endPoint: function (clientX, clientY, e) {\n\t\tif (this._mouseDownOrigin) {\n\t\t\tvar dragCheckDistance = L.point(clientX, clientY)\n\t\t\t\t.distanceTo(this._mouseDownOrigin);\n\t\t\tvar lastPtDistance = this._calculateFinishDistance(e.latlng);\n\t\t\tif (this.options.maxPoints > 1 && this.options.maxPoints == this._markers.length + 1) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (lastPtDistance < 10 && L.Browser.touch) {\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (Math.abs(dragCheckDistance) < 9 * (window.devicePixelRatio || 1)) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t}\n\t\t\tthis._enableNewMarkers(); // after a short pause, enable new markers\n\t\t}\n\t\tthis._mouseDownOrigin = null;\n\t},\n\n\t// ontouch prevented by clickHandled flag because some browsers fire both click/touch events,\n\t// causing unwanted behavior\n\t_onTouch: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX;\n\t\tvar clientY;\n\t\tif (originalEvent.touches && originalEvent.touches[0] && !this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tclientX = originalEvent.touches[0].clientX;\n\t\t\tclientY = originalEvent.touches[0].clientY;\n\t\t\tthis._disableNewMarkers();\n\t\t\tthis._touchHandled = true;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\t\tthis._touchHandled = null;\n\t\t}\n\t\tthis._clickHandled = null;\n\t},\n\n\t_onMouseOut: function () {\n\t\tif (this._tooltip) {\n\t\t\tthis._tooltip._onMouseOut.call(this._tooltip);\n\t\t}\n\t},\n\n\t// calculate if we are currently within close enough distance\n\t// of the closing point (first point for shapes, last point for lines)\n\t// this is semi-ugly code but the only reliable way i found to get the job done\n\t// note: calculating point.distanceTo between mouseDownOrigin and last marker did NOT work\n\t_calculateFinishDistance: function (potentialLatLng) {\n\t\tvar lastPtDistance;\n\t\tif (this._markers.length > 0) {\n\t\t\tvar finishMarker;\n\t\t\tif (this.type === L.Draw.Polyline.TYPE) {\n\t\t\t\tfinishMarker = this._markers[this._markers.length - 1];\n\t\t\t} else if (this.type === L.Draw.Polygon.TYPE) {\n\t\t\t\tfinishMarker = this._markers[0];\n\t\t\t} else {\n\t\t\t\treturn Infinity;\n\t\t\t}\n\t\t\tvar lastMarkerPoint = this._map.latLngToContainerPoint(finishMarker.getLatLng()),\n\t\t\t\tpotentialMarker = new L.Marker(potentialLatLng, {\n\t\t\t\t\ticon: this.options.icon,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t\t\t});\n\t\t\tvar potentialMarkerPint = this._map.latLngToContainerPoint(potentialMarker.getLatLng());\n\t\t\tlastPtDistance = lastMarkerPoint.distanceTo(potentialMarkerPint);\n\t\t} else {\n\t\t\tlastPtDistance = Infinity;\n\t\t}\n\t\treturn lastPtDistance;\n\t},\n\n\t_updateFinishHandler: function () {\n\t\tvar markerCount = this._markers.length;\n\t\t// The last marker should have a click handler to close the polyline\n\t\tif (markerCount > 1) {\n\t\t\tthis._markers[markerCount - 1].on('click', this._finishShape, this);\n\t\t}\n\n\t\t// Remove the old marker click handler (as only the last point should close the polyline)\n\t\tif (markerCount > 2) {\n\t\t\tthis._markers[markerCount - 2].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng) {\n\t\tvar marker = new L.Marker(latlng, {\n\t\t\ticon: this.options.icon,\n\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t});\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_updateGuide: function (newPos) {\n\t\tvar markerCount = this._markers ? this._markers.length : 0;\n\n\t\tif (markerCount > 0) {\n\t\t\tnewPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);\n\n\t\t\t// draw the guide line\n\t\t\tthis._clearGuides();\n\t\t\tthis._drawGuide(\n\t\t\t\tthis._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()),\n\t\t\t\tnewPos\n\t\t\t);\n\t\t}\n\t},\n\n\t_updateTooltip: function (latLng) {\n\t\tvar text = this._getTooltipText();\n\n\t\tif (latLng) {\n\t\t\tthis._tooltip.updatePosition(latLng);\n\t\t}\n\n\t\tif (!this._errorShown) {\n\t\t\tthis._tooltip.updateContent(text);\n\t\t}\n\t},\n\n\t_drawGuide: function (pointA, pointB) {\n\t\tvar length = Math.floor(Math.sqrt(Math.pow((pointB.x - pointA.x), 2) + Math.pow((pointB.y - pointA.y), 2))),\n\t\t\tguidelineDistance = this.options.guidelineDistance,\n\t\t\tmaxGuideLineLength = this.options.maxGuideLineLength,\n\t\t\t// Only draw a guideline with a max length\n\t\t\ti = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,\n\t\t\tfraction,\n\t\t\tdashPoint,\n\t\t\tdash;\n\n\t\t//create the guides container if we haven't yet\n\t\tif (!this._guidesContainer) {\n\t\t\tthis._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);\n\t\t}\n\n\t\t//draw a dash every GuildeLineDistance\n\t\tfor (; i < length; i += this.options.guidelineDistance) {\n\t\t\t//work out fraction along line we are\n\t\t\tfraction = i / length;\n\n\t\t\t//calculate new x,y point\n\t\t\tdashPoint = {\n\t\t\t\tx: Math.floor((pointA.x * (1 - fraction)) + (fraction * pointB.x)),\n\t\t\t\ty: Math.floor((pointA.y * (1 - fraction)) + (fraction * pointB.y))\n\t\t\t};\n\n\t\t\t//add guide dash to guide container\n\t\t\tdash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);\n\t\t\tdash.style.backgroundColor =\n\t\t\t\t!this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;\n\n\t\t\tL.DomUtil.setPosition(dash, dashPoint);\n\t\t}\n\t},\n\n\t_updateGuideColor: function (color) {\n\t\tif (this._guidesContainer) {\n\t\t\tfor (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\n\t\t\t\tthis._guidesContainer.childNodes[i].style.backgroundColor = color;\n\t\t\t}\n\t\t}\n\t},\n\n\t// removes all child elements (guide dashes) from the guides container\n\t_clearGuides: function () {\n\t\tif (this._guidesContainer) {\n\t\t\twhile (this._guidesContainer.firstChild) {\n\t\t\t\tthis._guidesContainer.removeChild(this._guidesContainer.firstChild);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar showLength = this.options.showLength,\n\t\t\tlabelText, distanceStr;\n\t\tif (this._markers.length === 0) {\n\t\t\tlabelText = {\n\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.start\n\t\t\t};\n\t\t} else {\n\t\t\tdistanceStr = showLength ? this._getMeasurementString() : '';\n\n\t\t\tif (this._markers.length === 1) {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.cont,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.end,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn labelText;\n\t},\n\n\t_updateRunningMeasure: function (latlng, added) {\n\t\tvar markersLength = this._markers.length,\n\t\t\tpreviousMarkerIndex, distance;\n\n\t\tif (this._markers.length === 1) {\n\t\t\tthis._measurementRunningTotal = 0;\n\t\t} else {\n\t\t\tpreviousMarkerIndex = markersLength - (added ? 2 : 1);\n\n\t\t\t// Calculate the distance based on the version\n\t\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\t\tdistance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\t\t\t} else {\n\t\t\t\tdistance = this._map.distance(latlng, this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\t\t\t}\n\n\t\t\tthis._measurementRunningTotal += distance * (added ? 1 : -1);\n\t\t}\n\t},\n\n\t_getMeasurementString: function () {\n\t\tvar currentLatLng = this._currentLatLng,\n\t\t\tpreviousLatLng = this._markers[this._markers.length - 1].getLatLng(),\n\t\t\tdistance;\n\n\t\t// Calculate the distance from the last fixed point to the mouse position based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tdistance = previousLatLng && currentLatLng && currentLatLng.distanceTo ? this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\n\t\t} else {\n\t\t\tdistance = previousLatLng && currentLatLng ? this._measurementRunningTotal + this._map.distance(currentLatLng, previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\n\t\t}\n\n\t\treturn L.GeometryUtil.readableDistance(distance, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);\n\t},\n\n\t_showErrorTooltip: function () {\n\t\tthis._errorShown = true;\n\n\t\t// Update tooltip\n\t\tthis._tooltip\n\t\t\t.showAsError()\n\t\t\t.updateContent({text: this.options.drawError.message});\n\n\t\t// Update shape\n\t\tthis._updateGuideColor(this.options.drawError.color);\n\t\tthis._poly.setStyle({color: this.options.drawError.color});\n\n\t\t// Hide the error after 2 seconds\n\t\tthis._clearHideErrorTimeout();\n\t\tthis._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\n\t},\n\n\t_hideErrorTooltip: function () {\n\t\tthis._errorShown = false;\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\t// Revert tooltip\n\t\tthis._tooltip\n\t\t\t.removeError()\n\t\t\t.updateContent(this._getTooltipText());\n\n\t\t// Revert shape\n\t\tthis._updateGuideColor(this.options.shapeOptions.color);\n\t\tthis._poly.setStyle({color: this.options.shapeOptions.color});\n\t},\n\n\t_clearHideErrorTimeout: function () {\n\t\tif (this._hideErrorTimeout) {\n\t\t\tclearTimeout(this._hideErrorTimeout);\n\t\t\tthis._hideErrorTimeout = null;\n\t\t}\n\t},\n\n\t// disable new markers temporarily;\n\t// this is to prevent duplicated touch/click events in some browsers\n\t_disableNewMarkers: function () {\n\t\tthis._disableMarkers = true;\n\t},\n\n\t// see _disableNewMarkers\n\t_enableNewMarkers: function () {\n\t\tsetTimeout(function () {\n\t\t\tthis._disableMarkers = false;\n\t\t}.bind(this), 50);\n\t},\n\n\t_cleanUpShape: function () {\n\t\tif (this._markers.length > 1) {\n\t\t\tthis._markers[this._markers.length - 1].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\n\t}\n});\n"]}